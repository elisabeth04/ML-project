a statistical language model is a probability distribution over sequences of words. given such a sequence, say of length m, it assigns a probability 
  
    
      
        p
        (
        
          w
          
            1
          
        
        ,
        …
        ,
        
          w
          
            m
          
        
        )
      
    
    {\displaystyle p(w_{1},\ldots ,w_{m})}
   to the whole sequence.
the language model provides context to distinguish between words and phrases that sound phonetically similar. for example, in american english, the phrases "recognize speech" and "wreck a nice beach" sound similar, but mean different things.
data sparsity is a major problem in building language models. most possible word sequences are not observed in training. one solution is to make the assumption that the probability of a word only depends on the previous n words. this is known as an n-gram model or unigram model when n = 1.
estimating the relative likelihood of different phrases is useful in many natural language processing applications, especially those that generate text as an output. language modeling is used in speech recognition, machine translation, part-of-speech tagging, parsing, optical character recognition, handwriting recognition, information retrieval and other applications.
in speech recognition, sounds are matched with word sequences. ambiguities are easier to resolve when evidence from the language model is integrated with a pronunciation model and an acoustic model.
language models are used in information retrieval in the query likelihood model. there, a separate language model is associated with each document in a collection. documents are ranked based on the probability of the query q in the document's language model 
  
    
      
        
          m
          
            d
          
        
      
    
    {\displaystyle m_{d}}
  : 
  
    
      
        p
        (
        q
        ∣
        
          m
          
            d
          
        
        )
      
    
    {\displaystyle p(q\mid m_{d})}
  . commonly, the unigram language model is used for this purpose.


== model types ==


=== unigram ===
a unigram model can be treated as the combination of several one-state finite automata. it splits the probabilities of different terms in a context, e.g. from 

  
    
      
        p
        (
        
          t
          
            1
          
        
        
          t
          
            2
          
        
        
          t
          
            3
          
        
        )
        =
        p
        (
        
          t
          
            1
          
        
        )
        p
        (
        
          t
          
            2
          
        
        ∣
        
          t
          
            1
          
        
        )
        p
        (
        
          t
          
            3
          
        
        ∣
        
          t
          
            1
          
        
        
          t
          
            2
          
        
        )
      
    
    {\displaystyle p(t_{1}t_{2}t_{3})=p(t_{1})p(t_{2}\mid t_{1})p(t_{3}\mid t_{1}t_{2})}
  to 

  
    
      
        
          p
          
            uni
          
        
        (
        
          t
          
            1
          
        
        
          t
          
            2
          
        
        
          t
          
            3
          
        
        )
        =
        p
        (
        
          t
          
            1
          
        
        )
        p
        (
        
          t
          
            2
          
        
        )
        p
        (
        
          t
          
            3
          
        
        )
        .
      
    
    {\displaystyle p_{\text{uni}}(t_{1}t_{2}t_{3})=p(t_{1})p(t_{2})p(t_{3}).}
  in this model, the probability of each word only depends on that word's own probability in the document, so we only have one-state finite automata as units. the automaton itself has a probability distribution over the entire vocabulary of the model, summing to 1. the following is an illustration of a unigram model of a document.

  
    
      
        
          ∑
          
            term in doc
          
        
        p
        (
        
          term
        
        )
        =
        1
      
    
    {\displaystyle \sum _{\text{term in doc}}p({\text{term}})=1}
  the probability generated for a specific query is calculated as

  
    
      
        p
        (
        
          query
        
        )
        =
        
          ∏
          
            term in query
          
        
        p
        (
        
          term
        
        )
      
    
    {\displaystyle p({\text{query}})=\prod _{\text{term in query}}p({\text{term}})}
  different documents have unigram models, with different hit probabilities of words in it. the probability distributions from different documents are used to generate hit probabilities for each query. documents can be ranked for a query according to the probabilities. example of unigram models of two documents:

in information retrieval contexts, unigram language models are often smoothed to avoid instances where p(term) = 0. a common approach is to generate a maximum-likelihood model for the entire collection and linearly interpolate the collection model with a maximum-likelihood model for each document to smooth the model.


=== n-gram ===

in an n-gram model, the probability 
  
    
      
        p
        (
        
          w
          
            1
          
        
        ,
        …
        ,
        
          w
          
            m
          
        
        )
      
    
    {\displaystyle p(w_{1},\ldots ,w_{m})}
   of observing the sentence 
  
    
      
        
          w
          
            1
          
        
        ,
        …
        ,
        
          w
          
            m
          
        
      
    
    {\displaystyle w_{1},\ldots ,w_{m}}
   is approximated as

  
    
      
        p
        (
        
          w
          
            1
          
        
        ,
        …
        ,
        
          w
          
            m
          
        
        )
        =
        
          ∏
          
            i
            =
            1
          
          
            m
          
        
        p
        (
        
          w
          
            i
          
        
        ∣
        
          w
          
            1
          
        
        ,
        …
        ,
        
          w
          
            i
            −
            1
          
        
        )
        ≈
        
          ∏
          
            i
            =
            1
          
          
            m
          
        
        p
        (
        
          w
          
            i
          
        
        ∣
        
          w
          
            i
            −
            (
            n
            −
            1
            )
          
        
        ,
        …
        ,
        
          w
          
            i
            −
            1
          
        
        )
      
    
    {\displaystyle p(w_{1},\ldots ,w_{m})=\prod _{i=1}^{m}p(w_{i}\mid w_{1},\ldots ,w_{i-1})\approx \prod _{i=1}^{m}p(w_{i}\mid w_{i-(n-1)},\ldots ,w_{i-1})}
  it is assumed that the probability of observing the ith word wi in the context history of the preceding i − 1 words can be approximated by the probability of observing it in the shortened context history of the preceding n − 1 words (nth order markov property).
the conditional probability can be calculated from n-gram model frequency counts:

  
    
      
        p
        (
        
          w
          
            i
          
        
        ∣
        
          w
          
            i
            −
            (
            n
            −
            1
            )
          
        
        ,
        …
        ,
        
          w
          
            i
            −
            1
          
        
        )
        =
        
          
            
              
                c
                o
                u
                n
                t
              
              (
              
                w
                
                  i
                  −
                  (
                  n
                  −
                  1
                  )
                
              
              ,
              …
              ,
              
                w
                
                  i
                  −
                  1
                
              
              ,
              
                w
                
                  i
                
              
              )
            
            
              
                c
                o
                u
                n
                t
              
              (
              
                w
                
                  i
                  −
                  (
                  n
                  −
                  1
                  )
                
              
              ,
              …
              ,
              
                w
                
                  i
                  −
                  1
                
              
              )
            
          
        
      
    
    {\displaystyle p(w_{i}\mid w_{i-(n-1)},\ldots ,w_{i-1})={\frac {\mathrm {count} (w_{i-(n-1)},\ldots ,w_{i-1},w_{i})}{\mathrm {count} (w_{i-(n-1)},\ldots ,w_{i-1})}}}
  the terms bigram and trigram language models denote n-gram models with n = 2 and n = 3, respectively.typically, the n-gram model probabilities are not derived directly from frequency counts, because models derived this way have severe problems when confronted with any n-grams that have not been explicitly seen before. instead, some form of smoothing is necessary, assigning some of the total probability mass to unseen words or n-grams. various methods are used, from simple "add-one" smoothing (assign a count of 1 to unseen n-grams, as an uninformative prior) to more sophisticated models, such as good-turing discounting or back-off models.


==== bidirectional ====
bidirectional representations condition on both pre- and post- context (e.g., words) in all layers.


==== example ====
in a bigram (n = 2) language model, the probability of the sentence i saw the red house is approximated as

  
    
      
        p
        (
        
          i, saw, the, red, house
        
        )
        ≈
        p
        (
        
          i
        
        ∣
        ⟨
        s
        ⟩
        )
        p
        (
        
          saw
        
        ∣
        
          i
        
        )
        p
        (
        
          the
        
        ∣
        
          saw
        
        )
        p
        (
        
          red
        
        ∣
        
          the
        
        )
        p
        (
        
          house
        
        ∣
        
          red
        
        )
        p
        (
        ⟨
        
          /
        
        s
        ⟩
        ∣
        
          house
        
        )
      
    
    {\displaystyle p({\text{i, saw, the, red, house}})\approx p({\text{i}}\mid \langle s\rangle )p({\text{saw}}\mid {\text{i}})p({\text{the}}\mid {\text{saw}})p({\text{red}}\mid {\text{the}})p({\text{house}}\mid {\text{red}})p(\langle /s\rangle \mid {\text{house}})}
  whereas in a trigram (n = 3) language model, the approximation is

  
    
      
        p
        (
        
          i, saw, the, red, house
        
        )
        ≈
        p
        (
        
          i
        
        ∣
        ⟨
        s
        ⟩
        ,
        ⟨
        s
        ⟩
        )
        p
        (
        
          saw
        
        ∣
        ⟨
        s
        ⟩
        ,
        i
        )
        p
        (
        
          the
        
        ∣
        
          i, saw
        
        )
        p
        (
        
          red
        
        ∣
        
          saw, the
        
        )
        p
        (
        
          house
        
        ∣
        
          the, red
        
        )
        p
        (
        ⟨
        
          /
        
        s
        ⟩
        ∣
        
          red, house
        
        )
      
    
    {\displaystyle p({\text{i, saw, the, red, house}})\approx p({\text{i}}\mid \langle s\rangle ,\langle s\rangle )p({\text{saw}}\mid \langle s\rangle ,i)p({\text{the}}\mid {\text{i, saw}})p({\text{red}}\mid {\text{saw, the}})p({\text{house}}\mid {\text{the, red}})p(\langle /s\rangle \mid {\text{red, house}})}
  note that the context of the first n – 1 n-grams is filled with start-of-sentence markers, typically denoted <s>.
additionally, without an end-of-sentence marker, the probability of an ungrammatical sequence *i saw the would always be higher than that of the longer sentence i saw the red house.


=== exponential ===
maximum entropy language models encode the relationship between a word and the n-gram history using feature functions. the equation is 

  
    
      
        p
        (
        
          w
          
            m
          
        
        ∣
        
          w
          
            1
          
        
        ,
        …
        ,
        
          w
          
            m
            −
            1
          
        
        )
        =
        
          
            1
            
              z
              (
              
                w
                
                  1
                
              
              ,
              …
              ,
              
                w
                
                  m
                  −
                  1
                
              
              )
            
          
        
        exp
        ⁡
        (
        
          a
          
            t
          
        
        f
        (
        
          w
          
            1
          
        
        ,
        …
        ,
        
          w
          
            m
          
        
        )
        )
      
    
    {\displaystyle p(w_{m}\mid w_{1},\ldots ,w_{m-1})={\frac {1}{z(w_{1},\ldots ,w_{m-1})}}\exp(a^{t}f(w_{1},\ldots ,w_{m}))}
  where 
  
    
      
        z
        (
        
          w
          
            1
          
        
        ,
        …
        ,
        
          w
          
            m
            −
            1
          
        
        )
      
    
    {\displaystyle z(w_{1},\ldots ,w_{m-1})}
   is the partition function, 
  
    
      
        a
      
    
    {\displaystyle a}
   is the parameter vector, and 
  
    
      
        f
        (
        
          w
          
            1
          
        
        ,
        …
        ,
        
          w
          
            m
          
        
        )
      
    
    {\displaystyle f(w_{1},\ldots ,w_{m})}
   is the feature function. in the simplest case, the feature function is just an indicator of the presence of a certain n-gram. it is helpful to use a prior on 
  
    
      
        a
      
    
    {\displaystyle a}
   or some form of regularization.
the log-bilinear model is another example of an exponential language model.


=== neural network ===
neural language models (or continuous space language models) use continuous representations or embeddings of words to make their predictions. these models make use of neural networks.
continuous space embeddings help to alleviate the curse of dimensionality in language modeling: as language models are trained on larger and larger texts, the number of unique words (the vocabulary) increases. the number of possible sequences of words increases exponentially with the size of the vocabulary, causing a data sparsity problem because of the exponentially many sequences. thus, statistics are needed to properly estimate probabilities. neural networks avoid this problem by representing words in a distributed way, as non-linear combinations of weights in a neural net. an alternate description is that a neural net approximates the language function. the neural net architecture might be feed-forward or recurrent, and while the former is simpler the latter is more common.typically, neural net language models are constructed and trained as probabilistic classifiers that learn to predict a probability distribution

  
    
      
        p
        (
        
          w
          
            t
          
        
        ∣
        
          c
          o
          n
          t
          e
          x
          t
        
        )
        
        ∀
        t
        ∈
        v
      
    
    {\displaystyle p(w_{t}\mid \mathrm {context} )\,\forall t\in v}
  .i.e., the network is trained to predict a probability distribution over the vocabulary, given some linguistic context. this is done using standard neural net training algorithms such as stochastic gradient descent with backpropagation. the context might be a fixed-size window of previous words, so that the network predicts

  
    
      
        p
        (
        
          w
          
            t
          
        
        ∣
        
          w
          
            t
            −
            k
          
        
        ,
        …
        ,
        
          w
          
            t
            −
            1
          
        
        )
      
    
    {\displaystyle p(w_{t}\mid w_{t-k},\dots ,w_{t-1})}
  from a feature vector representing the previous k words. another option is to use "future" words as well as "past" words as features, so that the estimated probability is

  
    
      
        p
        (
        
          w
          
            t
          
        
        ∣
        
          w
          
            t
            −
            k
          
        
        ,
        …
        ,
        
          w
          
            t
            −
            1
          
        
        ,
        
          w
          
            t
            +
            1
          
        
        ,
        …
        ,
        
          w
          
            t
            +
            k
          
        
        )
      
    
    {\displaystyle p(w_{t}\mid w_{t-k},\dots ,w_{t-1},w_{t+1},\dots ,w_{t+k})}
  .this is called a bag-of-words model. when the feature vectors for the words in the context are combined by a continuous operation, this model is referred to as the continuous bag-of-words architecture (cbow).a third option that trains slower than the cbow but performs slightly better is to invert the previous problem and make a neural network learn the context, given a word. more formally, given a sequence of training words 
  
    
      
        
          w
          
            1
          
        
        ,
        
          w
          
            2
          
        
        ,
        
          w
          
            3
          
        
        ,
        …
        ,
        
          w
          
            t
          
        
      
    
    {\displaystyle w_{1},w_{2},w_{3},\dots ,w_{t}}
  , one maximizes the average log-probability

  
    
      
        
          
            1
            t
          
        
        
          ∑
          
            t
            =
            1
          
          
            t
          
        
        
          ∑
          
            −
            k
            ≤
            j
            ≤
            k
            ,
            j
            ≠
            0
          
        
        log
        ⁡
        p
        (
        
          w
          
            t
            +
            j
          
        
        ∣
        
          w
          
            t
          
        
        )
      
    
    {\displaystyle {\frac {1}{t}}\sum _{t=1}^{t}\sum _{-k\leq j\leq k,j\neq 0}\log p(w_{t+j}\mid w_{t})}
  where k, the size of the training context, can be a function of the center word 
  
    
      
        
          w
          
            t
          
        
      
    
    {\displaystyle w_{t}}
  . this is called a skip-gram language model. bag-of-words and skip-gram models are the basis of the word2vec program.instead of using neural net language models to produce actual probabilities, it is common to instead use the distributed representation encoded in the networks' "hidden" layers as representations of words; each word is then mapped onto an n-dimensional real vector called the word embedding, where n is the size of the layer just before the output layer. the representations in skip-gram models have the distinct characteristic that they model semantic relations between words as linear combinations, capturing a form of compositionality. for example, in some such models, if v is the function that maps a word w to its n-d vector representation, then

  
    
      
        v
        (
        
          k
          i
          n
          g
        
        )
        −
        v
        (
        
          m
          a
          l
          e
        
        )
        +
        v
        (
        
          f
          e
          m
          a
          l
          e
        
        )
        ≈
        v
        (
        
          q
          u
          e
          e
          n
        
        )
      
    
    {\displaystyle v(\mathrm {king} )-v(\mathrm {male} )+v(\mathrm {female} )\approx v(\mathrm {queen} )}
  where ≈ is made precise by stipulating that its right-hand side must be the nearest neighbor of the value of the left-hand side.


=== other ===
a positional language model assesses the probability of given words occurring close to one another in a text, not necessarily immediately adjacent. similarly, bag-of-concepts models leverage the semantics associated with multi-word expressions such as buy_christmas_present, even when they are used in information-rich sentences like "today i bought a lot of very nice christmas presents".
despite the limited successes in using neural networks, authors acknowledge the need for other techniques when modelling sign languages.


== benchmarks ==
various data sets have been developed to use to evaluate language processing systems. these include:

corpus of linguistic acceptability
glue benchmark
microsoft research paraphrase corpus
multi-genre natural language inference
question natural language inference
quora question pairs
recognizing textual entailment
semantic textual similarity benchmark
squad question answering test
stanford sentiment treebank
winograd nli


== criticism ==
although contemporary language models, such as gpt-2, can be shown to match human performance on some tasks, it is not clear they are plausible cognitive models. for instance, recurrent neural networks have been shown to learn patterns humans do not learn and fail to learn patterns that humans do learn.


== see also ==


== notes ==


== references ==


=== citations ===


=== sources ===