a siamese neural network (sometimes called a twin neural network) is an artificial neural network that uses the same weights while working in tandem on two different input vectors to compute comparable output vectors. often one of the output vectors is precomputed, thus forming a baseline against which the other output vector is compared. this is similar to comparing fingerprints but can be described more technically as a distance function for locality-sensitive hashing.it is possible to build an architecture that is functionally similar to a siamese network but implements a slightly different function. this is typically used for comparing similar instances in different type sets.uses of similarity measures where a twin network might be used are such things as recognizing handwritten checks, automatic detection of faces in camera images, and matching queries with indexed documents. the perhaps most well-known application of twin networks are face recognition, where known images of people are precomputed and compared to an image from a turnstile or similar. it is not obvious at first, but there are two slightly different problems. one is recognizing a person among a large number of other persons, that is the facial recognition problem. deepface is an example of such a system. in its most extreme form this is recognizing a single person at a train station or airport. the other is face verification, that is to verify whether the photo in a pass is the same as the person claiming he or she is the same person. the twin network might be the same, but the implementation can be quite different.


== learning ==
learning in twin networks can be done with triplet loss or contrastive loss. for learning by triplet loss a baseline vector (anchor image) is compared against a positive vector (truthy image) and a negative vector (falsy image). the negative vector will force learning in the network, while the positive vector will act like a regularizer. for learning by contrastive loss there must be a weight decay to regularize the weights, or some similar operation like a normalization.
a distance metric for a loss function may have the following properties
non-negativity: 
  
    
      
        δ
        (
        x
        ,
        y
        )
        ≥
        0
      
    
    {\displaystyle \delta (x,y)\geq 0}
  
identity of non-discernibles: 
  
    
      
        δ
        (
        x
        ,
        y
        )
        =
        0
        
        ⟺
        
        x
        =
        y
      
    
    {\displaystyle \delta (x,y)=0\iff x=y}
  
symmetry: 
  
    
      
        δ
        (
        x
        ,
        y
        )
        =
        δ
        (
        y
        ,
        x
        )
      
    
    {\displaystyle \delta (x,y)=\delta (y,x)}
  
triangle inequality: 
  
    
      
        δ
        (
        x
        ,
        z
        )
        ≤
        δ
        (
        x
        ,
        y
        )
        +
        δ
        (
        y
        ,
        z
        )
      
    
    {\displaystyle \delta (x,z)\leq \delta (x,y)+\delta (y,z)}
  in particular, the triplet loss algorithm is often defined with squared euclidean (which unlike euclidean, does not have triangle inequality) distance at its core.


=== predefined metrics, euclidean distance metric ===
the common learning goal is to minimize a distance metric for similar objects and maximize for distinct ones. this gives a loss function like

  
    
      
        
          
            
              
                δ
                (
                
                  x
                  
                    (
                    i
                    )
                  
                
                ,
                
                  x
                  
                    (
                    j
                    )
                  
                
                )
                =
                
                  
                    {
                    
                      
                        
                          min
                           
                          ‖
                          f
                          ⁡
                          
                            (
                            
                              x
                              
                                (
                                i
                                )
                              
                            
                            )
                          
                          −
                          f
                          ⁡
                          
                            (
                            
                              x
                              
                                (
                                j
                                )
                              
                            
                            )
                          
                          ‖
                          
                          ,
                          i
                          =
                          j
                        
                      
                      
                        
                          max
                           
                          ‖
                          f
                          ⁡
                          
                            (
                            
                              x
                              
                                (
                                i
                                )
                              
                            
                            )
                          
                          −
                          f
                          ⁡
                          
                            (
                            
                              x
                              
                                (
                                j
                                )
                              
                            
                            )
                          
                          ‖
                          
                          ,
                          i
                          ≠
                          j
                        
                      
                    
                    
                  
                
              
            
          
        
      
    
    {\displaystyle {\begin{aligned}\delta (x^{(i)},x^{(j)})={\begin{cases}\min \ \|\operatorname {f} \left(x^{(i)}\right)-\operatorname {f} \left(x^{(j)}\right)\|\,,i=j\\\max \ \|\operatorname {f} \left(x^{(i)}\right)-\operatorname {f} \left(x^{(j)}\right)\|\,,i\neq j\end{cases}}\end{aligned}}}
  

  
    
      
        i
        ,
        j
      
    
    {\displaystyle i,j}
   are indexes into a set of vectors

  
    
      
        f
        ⁡
        (
        ⋅
        )
      
    
    {\displaystyle \operatorname {f} (\cdot )}
   function implemented by the twin networkthe most common distance metric used is euclidean distance, in case of which the loss function can be rewritten in matrix form as

  
    
      
        
          δ
        
        ⁡
        (
        
          
            x
          
          
            (
            i
            )
          
        
        ,
        
          
            x
          
          
            (
            j
            )
          
        
        )
        ≈
        (
        
          
            x
          
          
            (
            i
            )
          
        
        −
        
          
            x
          
          
            (
            j
            )
          
        
        
          )
          
            t
          
        
        (
        
          
            x
          
          
            (
            i
            )
          
        
        −
        
          
            x
          
          
            (
            j
            )
          
        
        )
      
    
    {\displaystyle \operatorname {\delta } (\mathbf {x} ^{(i)},\mathbf {x} ^{(j)})\approx (\mathbf {x} ^{(i)}-\mathbf {x} ^{(j)})^{t}(\mathbf {x} ^{(i)}-\mathbf {x} ^{(j)})}
  


=== learned metrics, nonlinear distance metric ===
a more general case is where the output vector from the twin network is passed through additional network layers implementing non-linear distance metrics.

  
    
      
        
          
            
              
                
                  if
                
                
                i
                =
                j
                
                
                  then
                
              
              
                
                
                  δ
                
                ⁡
                
                  [
                  
                    f
                    ⁡
                    
                      (
                      
                        x
                        
                          (
                          i
                          )
                        
                      
                      )
                    
                    ,
                    
                    f
                    ⁡
                    
                      (
                      
                        x
                        
                          (
                          j
                          )
                        
                      
                      )
                    
                  
                  ]
                
                
                
                  is small
                
              
            
            
              
                
                  otherwise
                
              
              
                
                
                  δ
                
                ⁡
                
                  [
                  
                    f
                    ⁡
                    
                      (
                      
                        x
                        
                          (
                          i
                          )
                        
                      
                      )
                    
                    ,
                    
                    f
                    ⁡
                    
                      (
                      
                        x
                        
                          (
                          j
                          )
                        
                      
                      )
                    
                  
                  ]
                
                
                
                  is large
                
              
            
          
        
      
    
    {\displaystyle {\begin{aligned}{\text{if}}\,i=j\,{\text{then}}&\,\operatorname {\delta } \left[\operatorname {f} \left(x^{(i)}\right),\,\operatorname {f} \left(x^{(j)}\right)\right]\,{\text{is small}}\\{\text{otherwise}}&\,\operatorname {\delta } \left[\operatorname {f} \left(x^{(i)}\right),\,\operatorname {f} \left(x^{(j)}\right)\right]\,{\text{is large}}\end{aligned}}}
  

  
    
      
        i
        ,
        j
      
    
    {\displaystyle i,j}
   are indexes into a set of vectors

  
    
      
        f
        ⁡
        (
        ⋅
        )
      
    
    {\displaystyle \operatorname {f} (\cdot )}
  function implemented by the twin network

  
    
      
        
          δ
        
        ⁡
        (
        ⋅
        )
      
    
    {\displaystyle \operatorname {\delta } (\cdot )}
  function implemented by the network joining outputs from the twin networkon a matrix form the previous is often approximated as a mahalanobis distance for a linear space as

  
    
      
        
          δ
        
        ⁡
        (
        
          
            x
          
          
            (
            i
            )
          
        
        ,
        
          
            x
          
          
            (
            j
            )
          
        
        )
        ≈
        (
        
          
            x
          
          
            (
            i
            )
          
        
        −
        
          
            x
          
          
            (
            j
            )
          
        
        
          )
          
            t
          
        
        
          m
        
        (
        
          
            x
          
          
            (
            i
            )
          
        
        −
        
          
            x
          
          
            (
            j
            )
          
        
        )
      
    
    {\displaystyle \operatorname {\delta } (\mathbf {x} ^{(i)},\mathbf {x} ^{(j)})\approx (\mathbf {x} ^{(i)}-\mathbf {x} ^{(j)})^{t}\mathbf {m} (\mathbf {x} ^{(i)}-\mathbf {x} ^{(j)})}
  this can be further subdivided in at least unsupervised learning and supervised learning.


=== learned metrics, half-twin networks ===
this form also allows the twin network to be more of a half-twin, implementing a slightly different functions

  
    
      
        
          
            
              
                
                  if
                
                
                i
                =
                j
                
                
                  then
                
              
              
                
                
                  δ
                
                ⁡
                
                  [
                  
                    f
                    ⁡
                    
                      (
                      
                        x
                        
                          (
                          i
                          )
                        
                      
                      )
                    
                    ,
                    
                    g
                    ⁡
                    
                      (
                      
                        x
                        
                          (
                          j
                          )
                        
                      
                      )
                    
                  
                  ]
                
                
                
                  is small
                
              
            
            
              
                
                  otherwise
                
              
              
                
                
                  δ
                
                ⁡
                
                  [
                  
                    f
                    ⁡
                    
                      (
                      
                        x
                        
                          (
                          i
                          )
                        
                      
                      )
                    
                    ,
                    
                    g
                    ⁡
                    
                      (
                      
                        x
                        
                          (
                          j
                          )
                        
                      
                      )
                    
                  
                  ]
                
                
                
                  is large
                
              
            
          
        
      
    
    {\displaystyle {\begin{aligned}{\text{if}}\,i=j\,{\text{then}}&\,\operatorname {\delta } \left[\operatorname {f} \left(x^{(i)}\right),\,\operatorname {g} \left(x^{(j)}\right)\right]\,{\text{is small}}\\{\text{otherwise}}&\,\operatorname {\delta } \left[\operatorname {f} \left(x^{(i)}\right),\,\operatorname {g} \left(x^{(j)}\right)\right]\,{\text{is large}}\end{aligned}}}
  

  
    
      
        i
        ,
        j
      
    
    {\displaystyle i,j}
   are indexes into a set of vectors

  
    
      
        f
        ⁡
        (
        ⋅
        )
        ,
        g
        ⁡
        (
        ⋅
        )
      
    
    {\displaystyle \operatorname {f} (\cdot ),\operatorname {g} (\cdot )}
  function implemented by the half-twin network

  
    
      
        
          δ
        
        ⁡
        (
        ⋅
        )
      
    
    {\displaystyle \operatorname {\delta } (\cdot )}
  function implemented by the network joining outputs from the twin network


== twin networks for object tracking ==
twin networks have been used in object tracking because of its unique two tandem inputs and similarity measurement. in object tracking, one input of the twin network is user pre-selected exemplar image, the other input is a larger search image, which twin network's job is to locate exemplar inside of search image. by measuring the similarity between exemplar and each part of the search image, a map of similarity score can be given by the twin network. furthermore, using a fully convolutional network, the process of computing each sector's similarity score can be replaced with only one cross correlation layer.after being first introduced in 2016, twin fully convolutional network has been used in many high-performance real-time object tracking neural networks.  like cfnet, structsiam, siamfc-tri, dsiam, sa-siam, siamrpn, dasiamrpn, cascaded siamrpn, siammask, siamrpn++, deeper and wider siamrpn.


== see also ==
artificial neural network
triplet loss


== further reading ==
chicco, davide (2020), "siamese neural networks: an overview", artificial neural networks, methods in molecular biology, vol. 2190 (3rd ed.), new york city, new york, usa: springer protocols, humana press, pp. 73–94, doi:10.1007/978-1-0716-0826-5_3, isbn 978-1-0716-0826-5, pmid 32804361


== references ==